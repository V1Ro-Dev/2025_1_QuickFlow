package http

import (
	"encoding/json"
	"fmt"
	"net/http"
	"unicode/utf8"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/microcosm-cc/bluemonday"

	time2 "quickflow/config/time"
	"quickflow/gateway/internal/delivery/forms"
	errors2 "quickflow/gateway/internal/errors"
	"quickflow/gateway/pkg/sanitizer"
	http2 "quickflow/gateway/utils/http"
	"quickflow/shared/logger"
	"quickflow/shared/models"
)

type MessageHandler struct {
	messageUseCase MessageService
	authUseCase    AuthUseCase
	profileUseCase ProfileUseCase
	policy         *bluemonday.Policy
}

func NewMessageHandler(messageUseCase MessageService, authUseCase AuthUseCase, profileUseCase ProfileUseCase, policy *bluemonday.Policy) *MessageHandler {
	return &MessageHandler{
		messageUseCase: messageUseCase,
		authUseCase:    authUseCase,
		profileUseCase: profileUseCase,
		policy:         policy,
	}
}

// GetMessagesForChat returns messages for a specific chat
// @Summary Get messages for chat
// @Description Get messages for a specific chat
// @Tags Messages
// @Accept json
// @Produce json
// @Param chat_id path string true "Chat ID"
// @Param posts_count query int true "Number of messages"
// @Param ts query string false "Timestamp"
// @Success 200 {array} forms.MessageOut "List of messages"
// @Failure 400 {object} forms.ErrorForm "Invalid data"
// @Failure 403 {object} forms.ErrorForm "User is not a participant in the chat"
// @Failure 500 {object} forms.ErrorForm "Server error"
// @Router /api/chats/{chat_id}/messages [get]
// GetMessagesForChat godoc
func (m *MessageHandler) GetMessagesForChat(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	// extracting user from context
	user, ok := ctx.Value("user").(models.User)
	if !ok {
		logger.Error(ctx, "Failed to get user from context while fetching messages")
		http2.WriteJSONError(w, "Failed to get user from context", http.StatusInternalServerError)
		return
	}
	chat := mux.Vars(r)["chat_id"]
	if len(chat) == 0 {
		logger.Info(ctx, "Fetch messages request without chat_id")
		http2.WriteJSONError(w, "chat_id is required", http.StatusBadRequest)
		return
	}

	chatId, err := uuid.Parse(chat)
	if err != nil {
		logger.Info(ctx, fmt.Sprintf("Failed to parse chat_id (uuid: %s): %s", chat, err.Error()))
		http2.WriteJSONError(w, "chat_id is not valid", http.StatusBadRequest)
		return
	}

	var messageForm forms.GetMessagesForm
	err = messageForm.GetParams(r.URL.Query())
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to parse query params: %v", err))
		http2.WriteJSONError(w, "Failed to parse query params", http.StatusBadRequest)
		return
	}

	logger.Info(ctx, fmt.Sprintf("Fetching feed for user %s with %d posts with timestamp %v (autogenerated: %t)", user.Username, messageForm.MessagesCount, messageForm.Ts, !r.URL.Query().Has("ts")))

	messages, err := m.messageUseCase.GetMessagesForChat(ctx, chatId, messageForm.MessagesCount, messageForm.Ts, user.Id)
	if err != nil {
		err := errors2.FromGRPCError(err)
		logger.Error(ctx, fmt.Sprintf("Failed to fetch messages: %v", err))
		http2.WriteJSONError(w, fmt.Sprintf("Failed to fetch messages: %v", err.Error()), err.HTTPStatus)
	}

	logger.Info(ctx, fmt.Sprintf("Fetched %d messages for user %s", len(messages), user.Username))

	senderIds := make([]uuid.UUID, 0, len(messages))
	for _, message := range messages {
		senderIds = append(senderIds, message.SenderID)
	}

	publicInfoMap := make(map[uuid.UUID]models.PublicUserInfo)
	if len(senderIds) != 0 {
		publicInfo, err := m.profileUseCase.GetPublicUsersInfo(ctx, senderIds)
		if err != nil {
			err := errors2.FromGRPCError(err)
			logger.Error(ctx, fmt.Sprintf("Error while fetching last messages users info: %v", err))
			http2.WriteJSONError(w, fmt.Sprintf("Failed to fetch last messages users info: %s", err.Error()), err.HTTPStatus)
			return
		}
		for _, info := range publicInfo {
			publicInfoMap[info.Id] = info
		}
	}
	getLastReadTs, err := m.messageUseCase.GetLastReadTs(ctx, chatId, user.Id)

	out := forms.MessagesOut{
		Messages: forms.ToMessagesOut(messages, publicInfoMap),
	}
	if err == nil {
		out.LastReadTs = getLastReadTs.Format(time2.TimeStampLayout)
	}
	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(out)
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to encode feed: %s", err.Error()))
		http2.WriteJSONError(w, "Failed to encode feed", http.StatusInternalServerError)
		return
	}
}

// SendMessageToUsername godoc
// @Summary Send message to user
// @Description Send message to user
// @Tags Messages
// @Accept json
// @Produce json
// @Param username path string true "ToSearch"
// @Param request body forms.MessageForm true "Message data"
// @Success 200 {object} forms.MessageOut "Message"
// @Failure 400 {object} forms.ErrorForm "Invalid data"
// @Failure 404 {object} forms.ErrorForm "User not found"
// @Failure 500 {object} forms.ErrorForm "Server error"
// @Router /api/messages/{username} [post]
func (m *MessageHandler) SendMessageToUsername(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	user, ok := ctx.Value("user").(models.User)
	if !ok {
		logger.Error(ctx, "Failed to get user from context while sending message")
		http2.WriteJSONError(w, "Failed to get user from context", http.StatusInternalServerError)
		return
	}
	logger.Info(ctx, fmt.Sprintf("User %s requested to send message", user.Username))

	username := mux.Vars(r)["username"]
	if len(username) == 0 {
		logger.Info(ctx, "Send message request without username")
		http2.WriteJSONError(w, "username is required", http.StatusBadRequest)
		return
	}

	userRecipient, err := m.authUseCase.GetUserByUsername(ctx, username)
	if err != nil {
		err := errors2.FromGRPCError(err)
		logger.Info(ctx, fmt.Sprintf("User %s not found", username))
		http2.WriteJSONError(w, "user not found", err.HTTPStatus)
		return
	}

	// parse JSON
	var messageForm forms.MessageForm
	err = json.NewDecoder(r.Body).Decode(&messageForm)
	if err != nil {
		logger.Error(ctx, "Failed to parse message body")
		http2.WriteJSONError(w, "Failed to parse message body", http.StatusBadRequest)
		return
	}

	if utf8.RuneCountInString(messageForm.Text) > 4000 {
		logger.Error(ctx, fmt.Sprintf("Text length validation failed: length=%d", utf8.RuneCountInString(messageForm.Text)))
		http2.WriteJSONError(w, "Text must be between 1 and 4096 characters", http.StatusBadRequest)
		return
	}

	sanitizer.SanitizeMessage(&messageForm, m.policy)

	messageForm.SenderId = user.Id
	messageForm.ReceiverId = userRecipient.Id

	message := messageForm.ToMessageModel()
	_, err = m.messageUseCase.SendMessage(ctx, &message, user.Id)
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to save message: %v", message))
		http2.WriteJSONError(w, "Failed to save message", http.StatusInternalServerError)
		return
	}
}
