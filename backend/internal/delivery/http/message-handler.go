package http

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"net/http"
	"quickflow/internal/delivery/forms"
	"quickflow/internal/models"
	"quickflow/internal/usecase"
	"quickflow/pkg/logger"
	http2 "quickflow/utils/http"
	"time"
)

type MessageUseCase interface {
	GetMessagesForChat(ctx context.Context, chatId uuid.UUID, userId uuid.UUID, numMessages int, timestamp time.Time) ([]models.Message, error)
	SaveMessage(ctx context.Context, message models.Message) error
	DeleteMessage(ctx context.Context, messageId uuid.UUID) error
	MarkRead(ctx context.Context, messageId uuid.UUID) error
}

type MessageHandler struct {
	messageUseCase MessageUseCase
	authUseCase    AuthUseCase
}

func NewMessageHandler(messageUseCase MessageUseCase, authUseCase AuthUseCase) *MessageHandler {
	return &MessageHandler{
		messageUseCase: messageUseCase,
		authUseCase:    authUseCase,
	}
}

// GetMessagesForChat returns messages for a specific chat
// @Summary Get messages for chat
// @Description Get messages for a specific chat
// @Tags Messages
// @Accept json
// @Produce json
// @Param chat_id path string true "Chat ID"
// @Param posts_count query int true "Number of messages"
// @Param ts query string false "Timestamp"
// @Success 200 {array} forms.MessageOut "List of messages"
// @Failure 400 {object} forms.ErrorForm "Invalid data"
// @Failure 403 {object} forms.ErrorForm "User is not a participant in the chat"
// @Failure 500 {object} forms.ErrorForm "Server error"
// @Router /api/messages/{chat_id} [get]
// GetMessagesForChat godoc
func (m *MessageHandler) GetMessagesForChat(w http.ResponseWriter, r *http.Request) {
	ctx := http2.SetRequestId(r.Context())
	// extracting user from context
	user, ok := ctx.Value("user").(models.User)
	if !ok {
		logger.Error(ctx, "Failed to get user from context while fetching messages")
		http2.WriteJSONError(w, "Failed to get user from context", http.StatusInternalServerError)
		return
	}
	chat := mux.Vars(r)["chat_id"]
	if len(chat) == 0 {
		logger.Info(ctx, "Fetch messages request without chat_id")
		http2.WriteJSONError(w, "chat_id is required", http.StatusBadRequest)
		return
	}

	chatId, err := uuid.Parse(chat)
	if err != nil {
		logger.Info(ctx, fmt.Sprintf("Failed to parse chat_id (uuid: %s): %s", chat, err.Error()))
		http2.WriteJSONError(w, "chat_id is not valid", http.StatusBadRequest)
		return
	}

	var messageForm forms.GetMessagesForm
	err = messageForm.GetParams(r.URL.Query())
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to parse query params: %v", err))
		http2.WriteJSONError(w, "Failed to parse query params", http.StatusBadRequest)
		return
	}

	logger.Info(ctx, fmt.Sprintf("Fetching feed for user %s with %d posts with timestamp %v (autogenerated: %t)", user.Username, messageForm.MessagesCount, messageForm.Ts, !r.URL.Query().Has("ts")))

	messages, err := m.messageUseCase.GetMessagesForChat(ctx, chatId, user.Id, messageForm.MessagesCount, messageForm.Ts)
	switch {
	case errors.Is(err, usecase.ErrNotParticipant):
		logger.Info(ctx, fmt.Sprintf("User %s is not a participant in chat %s", user.Username, chatId))
		http2.WriteJSONError(w, "user is not a participant in chat", http.StatusForbidden)
		return
	case errors.Is(err, usecase.ErrInvalidNumMessages):
		logger.Info(ctx, fmt.Sprintf("Invalid number of messages requested: %d", messageForm.MessagesCount))
		http2.WriteJSONError(w, "numMessages must be greater than 0", http.StatusBadRequest)
		return
	case err != nil:
		logger.Error(ctx, fmt.Sprintf("Failed to fetch messages: %v", err))
		http2.WriteJSONError(w, "Failed to fetch messages", http.StatusInternalServerError)
		return
	}

	logger.Info(ctx, fmt.Sprintf("Fetched %d messages for user %s", len(messages), user.Username))
	messagesOut := forms.ToMessagesOut(messages)
	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(messagesOut)
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to encode feed: %s", err.Error()))
		http2.WriteJSONError(w, "Failed to encode feed", http.StatusInternalServerError)
		return
	}
}

// SendMessageToUsername godoc
// @Summary Send message to user
// @Description Send message to user
// @Tags Messages
// @Accept json
// @Produce json
// @Param username path string true "Username"
// @Param request body forms.MessageForm true "Message data"
// @Success 200 {object} forms.MessageOut "Message"
// @Failure 400 {object} forms.ErrorForm "Invalid data"
// @Failure 404 {object} forms.ErrorForm "User not found"
// @Failure 500 {object} forms.ErrorForm "Server error"
// @Router /api/messages/{username} [post]
func (m *MessageHandler) SendMessageToUsername(w http.ResponseWriter, r *http.Request) {
	ctx := http2.SetRequestId(r.Context())
	user, ok := ctx.Value("user").(models.User)
	if !ok {
		logger.Error(ctx, "Failed to get user from context while sending message")
		http2.WriteJSONError(w, "Failed to get user from context", http.StatusInternalServerError)
		return
	}
	logger.Info(ctx, fmt.Sprintf("User %s requested to send message", user.Username))

	username := mux.Vars(r)["username"]
	if len(username) == 0 {
		logger.Info(ctx, "Send message request without username")
		http2.WriteJSONError(w, "username is required", http.StatusBadRequest)
		return
	}

	userRecipient, err := m.authUseCase.GetUserByUsername(ctx, username)
	if errors.Is(err, usecase.ErrNotFound) {
		logger.Info(ctx, fmt.Sprintf("User %s not found", username))
		http2.WriteJSONError(w, "user not found", http.StatusNotFound)
		return
	} else if err != nil {
		logger.Error(ctx, "Failed to get user")
		http2.WriteJSONError(w, "Failed to get user", http.StatusInternalServerError)
		return
	}

	// parse JSON
	var messageForm forms.MessageForm
	err = json.NewDecoder(r.Body).Decode(&messageForm)
	if err != nil {
		logger.Error(ctx, "Failed to parse message body")
		http2.WriteJSONError(w, "Failed to parse message body", http.StatusBadRequest)
		return
	}

	messageForm.SenderId = user.Id
	messageForm.ReceiverId = userRecipient.Id

	message := messageForm.ToMessageModel()
	err = m.messageUseCase.SaveMessage(ctx, message)
	if err != nil {
		logger.Error(ctx, "Failed to save message: %v", message)
		http2.WriteJSONError(w, "Failed to save message", http.StatusInternalServerError)
		return
	}
}
