package http

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/mux"

	time2 "quickflow/monolith/config/time"
	"quickflow/monolith/internal/delivery/forms"
	"quickflow/monolith/internal/models"
	"quickflow/monolith/internal/usecase"
	"quickflow/monolith/pkg/logger"
	http2 "quickflow/monolith/utils/http"
)

type PostUseCase interface {
	FetchFeed(ctx context.Context, user models.User, numPosts int, timestamp time.Time) ([]models.Post, error)
	FetchRecommendations(ctx context.Context, user models.User, numPosts int, timestamp time.Time) ([]models.Post, error)
	FetchUserPosts(ctx context.Context, user models.User, numPosts int, timestamp time.Time) ([]models.Post, error)
	AddPost(ctx context.Context, post models.Post) (models.Post, error)
	DeletePost(ctx context.Context, user models.User, postId uuid.UUID) error
	UpdatePost(ctx context.Context, update models.PostUpdate, userId uuid.UUID) (models.Post, error)
}

type FeedHandler struct {
	authUseCase    AuthUseCase
	postUseCase    PostUseCase
	profileUseCase ProfileUseCase
	friendUseCase  FriendsUseCase
}

// NewFeedHandler creates new feed handler.
func NewFeedHandler(authUseCase AuthUseCase, postUseCase PostUseCase, profileUseCase ProfileUseCase, friendUseCase FriendsUseCase) *FeedHandler {
	return &FeedHandler{
		postUseCase:    postUseCase,
		profileUseCase: profileUseCase,
		friendUseCase:  friendUseCase,
		authUseCase:    authUseCase,
	}
}

// GetFeed возвращает ленту постов
// @Summary Получить ленту
// @Description Возвращает список постов, опубликованных до указанного времени
// @Tags Feed
// @Produce json
// @Param posts_count query int true "Количество постов"
// @Param ts query string false "Временная метка"
// @Success 200 {array} forms.PostOut "Список постов"
// @Failure 400 {object} forms.ErrorForm "Некорректные данные"
// @Failure 500 {object} forms.ErrorForm "Ошибка сервера"
// @Router /api/feed [get]
func (f *FeedHandler) GetFeed(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	// extracting user from context
	user, ok := ctx.Value("user").(models.User)
	if !ok {
		logger.Error(ctx, "Failed to get user from context while fetching feed")
		http2.WriteJSONError(w, "Failed to get user from context", http.StatusInternalServerError)
		return
	}
	logger.Info(ctx, fmt.Sprintf("User %s requested feed", user.Username))

	// parsing JSON
	var feedForm forms.FeedForm
	err := feedForm.GetParams(r.URL.Query())
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to parse query params: %v", err))
		http2.WriteJSONError(w, "Failed to parse query params", http.StatusBadRequest)
		return
	}

	ts, err := time.Parse(time2.TimeStampLayout, feedForm.Ts)
	if err != nil {
		ts = time.Now()
	}

	logger.Info(ctx, fmt.Sprintf("Fetching feed for user %s with %d posts with timestamp %v (autogenerated: %t)", user.Username, feedForm.Posts, ts, err != nil))
	posts, err := f.postUseCase.FetchFeed(ctx, user, feedForm.Posts, ts)
	if errors.Is(err, usecase.ErrInvalidNumPosts) {
		logger.Info(ctx, fmt.Sprintf("Invalid numPosts for user %v: %v", user, err))
		http2.WriteJSONError(w, "Invalid numPosts", http.StatusBadRequest)
		return
	} else if errors.Is(err, usecase.ErrInvalidTimestamp) {
		logger.Info(ctx, fmt.Sprintf("Invalid timestamp for user %v: %v", user, err))
		http2.WriteJSONError(w, "Invalid timestamp", http.StatusBadRequest)
		return
	} else if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to fetch feed: %v", err))
		http2.WriteJSONError(w, "Failed to load feed", http.StatusInternalServerError)
		return
	}

	logger.Info(ctx, fmt.Sprintf("Fetched %d posts for user %s", len(posts), user.Username))
	var postsOut []forms.PostOut
	var authors []uuid.UUID
	for _, post := range posts {
		var postOut forms.PostOut
		postOut.FromPost(post)
		postsOut = append(postsOut, postOut)
		authors = append(authors, post.CreatorId)
	}

	// Fetching authors
	publicAuthorsInfo, err := f.profileUseCase.GetPublicUsersInfo(ctx, authors)
	for i := range postsOut {
		rel, err := f.friendUseCase.GetUserRelation(ctx, user.Id, authors[i])
		if err != nil {
			logger.Error(ctx, fmt.Sprintf("Failed to get user relation: %s", err.Error()))
			http2.WriteJSONError(w, "Failed to get user relation", http.StatusInternalServerError)
			return
		}

		postsOut[i].Creator = forms.PublicUserInfoToOut(publicAuthorsInfo[authors[i]], rel)
	}

	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(postsOut)
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to encode feed: %s", err.Error()))
		http2.WriteJSONError(w, "Failed to encode feed", http.StatusInternalServerError)
		return
	}
}

// GetRecommendations возвращает рекомендации
// @Summary Получить рекомендации
// @Description Возвращает список постов, опубликованных до указанного времени
// @Tags Feed
// @Produce json
// @Param posts_count query int true "Количество постов"
// @Param ts query string false "Временная метка"
// @Success 200 {array} forms.PostOut "Список постов"
// @Failure 400 {object} forms.ErrorForm "Некорректные данные"
// @Failure 500 {object} forms.ErrorForm "Ошибка сервера"
// @Router /api/recommendations [get]
// @Security Session
func (f *FeedHandler) GetRecommendations(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	// extracting user from context
	user, ok := ctx.Value("user").(models.User)
	if !ok {
		logger.Error(ctx, "Failed to get user from context while fetching recommendations")
		http2.WriteJSONError(w, "Failed to get user from context", http.StatusInternalServerError)
		return
	}
	logger.Info(ctx, fmt.Sprintf("User %s requested recommendations", user.Username))

	// parsing JSON
	var feedForm forms.FeedForm
	err := feedForm.GetParams(r.URL.Query())
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to parse query params: %v", err))
		http2.WriteJSONError(w, "Failed to parse query params", http.StatusBadRequest)
		return
	}

	ts, err := time.Parse(time2.TimeStampLayout, feedForm.Ts)
	if err != nil {
		ts = time.Now()
	}

	logger.Info(ctx, fmt.Sprintf("Fetching recommendations for user %s with %d posts with timestamp %v (autogenerated: %t)", user.Username, feedForm.Posts, ts, err != nil))
	posts, err := f.postUseCase.FetchRecommendations(ctx, user, feedForm.Posts, ts)
	if errors.Is(err, usecase.ErrInvalidNumPosts) {
		logger.Info(ctx, fmt.Sprintf("Invalid numPosts for user %v: %v", user, err))
		http2.WriteJSONError(w, "Invalid numPosts", http.StatusBadRequest)
		return
	} else if errors.Is(err, usecase.ErrInvalidTimestamp) {
		logger.Info(ctx, fmt.Sprintf("Invalid timestamp for user %v: %v", user, err))
		http2.WriteJSONError(w, "Invalid timestamp", http.StatusBadRequest)
		return
	} else if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to fetch recommendations: %v", err))
		http2.WriteJSONError(w, "Failed to load recommendations", http.StatusInternalServerError)
		return
	}

	logger.Info(ctx, fmt.Sprintf("Fetched %d posts for user %s", len(posts), user.Username))
	var postsOut []forms.PostOut
	var authors []uuid.UUID
	for _, post := range posts {
		var postOut forms.PostOut
		postOut.FromPost(post)
		postsOut = append(postsOut, postOut)
		authors = append(authors, post.CreatorId)
	}

	publicAuthorsInfo, err := f.profileUseCase.GetPublicUsersInfo(ctx, authors)
	for i := range postsOut {
		rel, err := f.friendUseCase.GetUserRelation(ctx, user.Id, authors[i])
		if err != nil {
			logger.Error(ctx, fmt.Sprintf("Failed to get user relation: %s", err.Error()))
			http2.WriteJSONError(w, "Failed to get user relation", http.StatusInternalServerError)
			return
		}

		postsOut[i].Creator = forms.PublicUserInfoToOut(publicAuthorsInfo[authors[i]], rel)
	}

	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(postsOut)
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to encode recommendations: %s", err.Error()))
		http2.WriteJSONError(w, "Failed to encode recommendations", http.StatusInternalServerError)
	}
}

// FetchUserPosts возвращает посты пользователя
// @Summary Получить посты пользователя
// @Description Возвращает список постов пользователя, опубликованных до указанного времени
// @Tags Feed
// @Produce json
// @Param posts_count query int true "Количество постов"
// @Param ts query string false "Временная метка"
// @Success 200 {array} forms.PostOut "Список постов"
// @Failure 400 {object} forms.ErrorForm "Некорректные данные"
// @Failure 500 {object} forms.ErrorForm "Ошибка сервера"
// @Router /api/profiles/{username}/posts [get]
// @Security Session
func (f *FeedHandler) FetchUserPosts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// extracting username from URL
	username := mux.Vars(r)["username"]
	if username == "" {
		logger.Error(ctx, "Failed to get username from URL")
		http2.WriteJSONError(w, "Failed to get username from URL", http.StatusBadRequest)
		return
	}
	user, err := f.authUseCase.GetUserByUsername(ctx, username)
	if errors.Is(err, usecase.ErrNotFound) {
		logger.Error(ctx, fmt.Sprintf("User %s not found", username))
		http2.WriteJSONError(w, "User not found", http.StatusNotFound)
		return
	} else if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to get user by username: %s", err.Error()))
		http2.WriteJSONError(w, "Failed to get user by username", http.StatusInternalServerError)
		return
	}

	// extracting requester from context
	requester, ok := ctx.Value("user").(models.User)
	if !ok {
		logger.Info(ctx, fmt.Sprintf("Guest reqested users posts: %v", user))
	} else {
		logger.Info(ctx, fmt.Sprintf("User %s requested user posts by user %v", requester.Username, user))
	}

	// parsing JSON
	var feedForm forms.FeedForm
	err = feedForm.GetParams(r.URL.Query())
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to parse query params: %v", err))
		http2.WriteJSONError(w, "Failed to parse query params", http.StatusBadRequest)
		return
	}

	ts, err := time.Parse(time2.TimeStampLayout, feedForm.Ts)
	if err != nil {
		ts = time.Now()
	}

	logger.Info(ctx, fmt.Sprintf("Fetching user posts for user %s with %d posts with timestamp %v (autogenerated: %t)", user.Username, feedForm.Posts, ts, err != nil))
	posts, err := f.postUseCase.FetchUserPosts(ctx, user, feedForm.Posts, ts)
	if errors.Is(err, usecase.ErrInvalidNumPosts) {
		logger.Info(ctx, fmt.Sprintf("Invalid numPosts for user %v: %v", user, err))
		http2.WriteJSONError(w, "Invalid numPosts", http.StatusBadRequest)
		return
	} else if errors.Is(err, usecase.ErrInvalidTimestamp) {
		logger.Info(ctx, fmt.Sprintf("Invalid timestamp for user %v: %v", user, err))
		http2.WriteJSONError(w, "Invalid timestamp", http.StatusBadRequest)
		return
	} else if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to fetch recommendations: %v", err))
		http2.WriteJSONError(w, "Failed to load recommendations", http.StatusInternalServerError)
		return
	}

	publicUserInfo, err := f.profileUseCase.GetPublicUserInfo(ctx, user.Id)
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to fetch user info: %v", err))
		http2.WriteJSONError(w, "Failed to load user info", http.StatusInternalServerError)
		return
	}

	logger.Info(ctx, fmt.Sprintf("Fetched %d posts for user %s", len(posts), user.Username))
	var postsOut []forms.PostOut
	for _, post := range posts {
		var postOut forms.PostOut
		postOut.FromPost(post)
		postsOut = append(postsOut, postOut)
	}

	for i := range postsOut {
		postsOut[i].Creator = forms.PublicUserInfoToOut(publicUserInfo, models.RelationSelf)
	}

	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(postsOut)
	if err != nil {
		logger.Error(ctx, fmt.Sprintf("Failed to encode recommendations: %s", err.Error()))
		http2.WriteJSONError(w, "Failed to encode recommendations", http.StatusInternalServerError)
	}
}
